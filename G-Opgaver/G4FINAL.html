
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bi simulation</title>
</head>
<body>
    <h1>Bi Simulation med 1 blomsterbed</h1>
    <form id="simulationForm">
        	<!-- OPGAVE -- Lav en form, hvor de relevante v칝rdier kan afgives, husk validering af input -->
        <label for="antalBier">Antal Bier:</label>
        <input type="number" id="antalBier" name="antalBier" min="1" required>
        <br>
        <label for="SizeX">Eng Bredde (X, min 5):</label>
        <input type="number" id="SizeX" name="SizeX" min="5" required>
        <br>
        <label for="SizeY">Eng L칝ngde (Y, min 5):</label>
        <input type="number" id="SizeY" name="SizeY" min="5" required>
        <br><br>
        <button id="Simulationstart" type="submit">Start Simulation</button>
    </form>

    <canvas id="beeCanvas" width="600" height="600" style="border: 1px solid black;"></canvas>

    <div id="rundeCounter">Runde: 0</div>
    <div id="blomstCounter">Blomster: 9</div>

    <script>
        // definere vores emoji kombinationer 
const gr칝s = "游꺔游꺔";
const bi = "游냏游꺔";
const blomst = "游꺔游꺝";
const blomstBi = "游냏游꺝";

// BlomsterEng klasse (Opgavekrav) 
class BlomsterEng {
    constructor(h칮jde, bredde, antalBier) {
        if (h칮jde < 5 || bredde < 5) { // Opgavekrav at der mindst skal v칝re 5x5 eng st칮rrelse 
            throw new Error("Eng skal mindst v칝re 5x5");
        }
        this.h칮jde = h칮jde;
        this.bredde = bredde;
        this.myEng = this.opretEng();
        this.antalBier = antalBier;
        this.nuv칝rendeBier = 0;
        this.antalBlomster = 0;
    }

    opretEng() { // bruger array.from til at tage input og danne et array, i arrayet putter vi gr칝s i felterne 
        return Array.from({ length: this.h칮jde }, () =>
            Array.from({ length: this.bredde }, () => gr칝s)
        );
    }

    placerBlomsterBed() { // placere blomster i arrayet 
        let h칮jdeIndexBlomsterBed = Math.floor(Math.random() * (this.h칮jde - 2));
        let breddeIndexBlomsterBed = Math.floor(Math.random() * (this.bredde - 2));
        // for at placere en 3x3 array, skal der mindst v칝re 2 pladser ved enderne, derfor minusser vi 2 fra l칝ngden og h칮jden 
        // vi generer s친 ogs친 en tilf칝ldig "칮verst venstre" placering for en blomst, hvorefter vi fylder resten af engen 
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                this.myEng[h칮jdeIndexBlomsterBed + i][breddeIndexBlomsterBed + j] = blomst;
                this.antalBlomster++; // t칝ller antallet af blomster 
            }
        }
    }

    placerBier() { // efter blomst placering, er det nu tid til bier 
        while (this.nuv칝rendeBier < this.antalBier) { // placer bier indtil det 칮nsket antal er opn친et 
            let h칮jdeIndexBi = Math.floor(Math.random() * this.h칮jde);
            let breddeIndexBi = Math.floor(Math.random() * this.bredde);

            if (this.myEng[h칮jdeIndexBi][breddeIndexBi] === gr칝s) { // placer bierne de steder hvor der kun er gr칝s 
                this.myEng[h칮jdeIndexBi][breddeIndexBi] = bi;
                this.nuv칝rendeBier++;
            }
        }
    }

    bev칝geBier() {
        // vi bev칝ger bier ved at fjerne alle bierne, derefter generer tilf칝ldig position, og derefter placer dem igen 
        for (let i = 0; i < this.h칮jde; i++) {
            for (let j = 0; j < this.bredde; j++) {
                if (this.myEng[i][j] === bi || this.myEng[i][j] === blomstBi) {
                    if (this.myEng[i][j] === blomstBi) {
                        this.myEng[i][j] = gr칝s;
                        this.antalBlomster--; // hvis bien lander p친 blomst, juter antallet af blomster 
                        this.nuv칝rendeBier--;
                    } else if (this.myEng[i][j] === bi) { // hvis ikke, s친 fjern bien 
                        this.myEng[i][j] = gr칝s;
                        this.nuv칝rendeBier--;
                    }
                }
            }
        }

        while (this.nuv칝rendeBier < this.antalBier) { // igen placer vi bier, indtil det 칮nskede antal er n친et 
            let h칮jdeIndexBi = Math.floor(Math.random() * this.h칮jde);
            let breddeIndexBi = Math.floor(Math.random() * this.bredde);

            if (this.myEng[h칮jdeIndexBi][breddeIndexBi] === blomst) { // hvis den valgte bi position er bloms, bliver det til bi og blomst 
                this.myEng[h칮jdeIndexBi][breddeIndexBi] = blomstBi;
                this.nuv칝rendeBier++;
            } else if (this.myEng[h칮jdeIndexBi][breddeIndexBi] === gr칝s) { // hvis det lander p친 gr칝s, bliver det bi gr칝s 
                this.myEng[h칮jdeIndexBi][breddeIndexBi] = bi;
                this.nuv칝rendeBier++;
            }
        }
    }
}

class Simulation {
    constructor(h칮jde, bredde, blomsterbed, bier) {
        this.h칮jde = h칮jde;
        this.bredde = bredde;
        this.blomsterbed = blomsterbed;
        this.bier = bier;
        this.eng = new BlomsterEng(h칮jde, bredde, bier); // Eng oprettes i BlomsterEng klassen med opretEng() funktion 
    }

    run(callback) { // vi k칮rer simulationen igennem run()
        for (let i = 0; i < this.blomsterbed; i++) {
            this.eng.placerBlomsterBed(); // placer 1 blomsterbed 
        }
        this.eng.placerBier(); // placere antal bier som brugeren har givet 

        let antalRunder = 0; // rundet칝ller 
        const interval = setInterval(() => { // vi k칮rer koden indenfor setInterval med 500ms delay 
            if (this.eng.antalBlomster === 0) {
                clearInterval(interval); // stopper intervallet med at k칮re 
                alert("Simulationen er f칝rdig!"); // hvis ikke flere blomster, popup for f칝rdig simulation 
            } else { // s친 l칝nge der er blomster tilbage 
                this.eng.bev칝geBier(); 
                antalRunder++;
                callback(this.eng.myEng, antalRunder, this.eng.antalBlomster);// vi bruger callback til at kalde p친 de opdaterede placeringer og runder 
            }
        }, 650); // l칝ngden af delay (ms)
    }
}

// Canvas-visualisering
function renderState(eng, antalRunder, antalBlomster) { // eng refere til this.eng.myEng i run metoden, alts친 vores array. 
    const canvas = document.getElementById("beeCanvas"); // tager fat i canvas
    const ctx = canvas.getContext("2d");
    const cellSize = canvas.width / eng[0].length; // Beregner celle-st칮rrelse baseret p친 gridets bredde (her eng)

    ctx.clearRect(0, 0, canvas.width, canvas.height); // Vi sletter alle emojis p친 canvas, for s친 bagefter at tilf칮je dem igen. Det er hele canvas fordi vi tager den fra 0,0 til l칝ngden og bredden 

    for (let y = 0; y < eng.length; y++) { // dobbelt forloop til at gennemg친 arrayet og placere emojis 
        for (let x = 0; x < eng[y].length; x++) {

            // Tegn griddet op 
            ctx.strokeStyle = "black"; // sorte streger 
            ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize); // vi tegner en grid firkant p친 st칮rrelsen cellSize, og hvergang x og y rykker, rykkes startpunktet for strokeRect ogs친. Dermed tegner man hele engen. 

            // Tegn emoji i cellen
            let emoji = eng[y][x]; // hver punkt i vores array er givet ved emojis, og vi gemmer emojien for det punkt, for s친 at tegne det i html
            ctx.font = `${cellSize * 0.3}px Arial`; // Justerer fontst칮rrelsen s친 emojien kan v칝re i cellen 
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(emoji, // vi indtegner vores emojis i en celle og placere den i midten 
            x * cellSize + cellSize / 2, // Midtpunkt af cellen (x) 
            y * cellSize + cellSize / 2  // Midtpunkt af cellen (y)
            );
        }
    }

    // Opdater runde- og blomster-t칝llere
    // Vigtigt at vi s칝tter `${x}` s친 v칝rdien af variablen vises selv n친r den opdatere. 
    document.getElementById("rundeCounter").textContent = `Runde: ${antalRunder}`;
    document.getElementById("blomstCounter").textContent = `Blomster: ${antalBlomster}`;
}

// Form-eventhandler & hente bruger input 

// N친r brugeren trykker "submit" eller p친 start simulation knappen, ville siden reloade fordi der er en form der har modtaget data
// Hvis siden opdatere ville de v칝rdien brugeren har sat ind blive slettet, og dermed ville simulationen ikke starte 
// Vi blokerer reloaded af siden med "preventDefault()"

document.getElementById("simulationForm").addEventListener("submit", (e) => {
    e.preventDefault();
    // Gemmer v칝rdier som brugeren giver 
    // parseInt, fordi brugeren angiver et tal 
    const antalBier = parseInt(document.getElementById("antalBier").value);
    const bredde = parseInt(document.getElementById("SizeX").value);
    const h칮jde = parseInt(document.getElementById("SizeY").value);

    // Vi bruger de v칝rdier brugeren har givet, og der kan kun v칝re 1 eng. 
    const simulation = new Simulation(h칮jde, bredde, 1, antalBier);
    simulation.run(renderState);
});

        
    </script>
</body>
</html>
